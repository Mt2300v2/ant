<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Sim</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; height: 100vh; }
        canvas { display: block; background-color: #000; cursor: default; }
        #controls { position: absolute; top: 10px; right: 10px; background-color: rgba(50, 50, 50, 0.85); padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; gap: 8px; align-items: flex-start; z-index: 10; max-height: 90vh; overflow-y: auto; transition: right 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out; width: 200px; box-sizing: border-box;}
        #controls.hidden { right: -210px; opacity: 0; padding: 0; border: none; overflow: hidden; }
        #controls label, #controls span { display: block; margin-bottom: 2px; font-size: 12px; color: #ccc; }
        #controls input[type="range"] { width: 160px; cursor: pointer; }
        #controls input[type="text"], #controls input[type="number"] { width: 160px; padding: 4px; background-color: #333; border: 1px solid #555; color: #eee; border-radius: 3px; font-size: 12px; margin-top: 2px; box-sizing: border-box; }
        #controls .control-group { margin-bottom: 5px; width: 100%; }
        #controls .colony-stats { border-left: 3px solid; padding-left: 5px; margin-bottom: 10px; }
        #controls button { padding: 8px 15px; background-color: #444; color: #eee; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; font-size: 12px; width: 100%; box-sizing: border-box; margin-top: 5px; }
        #controls button:hover { background-color: #555; }
        #controls button#applySeedBtn { background-color: #006400; }
        #controls button#applySeedBtn:hover { background-color: #008000; }
        #togglePanelBtn { position: absolute; top: 10px; right: 10px; z-index: 11; background-color: #555; color: #eee; border: none; padding: 5px 10px; cursor: pointer; border-radius: 4px 0 0 4px; font-size: 10px; transition: right 0.3s ease-in-out; }
        #controls.hidden + #togglePanelBtn { right: 0; border-radius: 4px; }
        #tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 5px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; display: none; white-space: pre; z-index: 20; }
        #debug { position: fixed; top: 10px; left: 10px; color: white; font-family: monospace; font-size: 12px; background-color: rgba(0, 0, 0, 0.6); padding: 3px 6px; border-radius: 3px; z-index: 15; pointer-events: none; max-width: 350px; word-wrap: break-word; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <div id="colonyDisplayContainer"></div>
        <div class="control-group"><label for="foodRateSlider">Food Spawn Rate:</label><input type="range" id="foodRateSlider" min="0.001" max="0.1" step="0.001" value="0.01"><span id="foodRateLabel">0.01</span></div>
        <div class="control-group"><label for="consumptionRateSlider">Ant Food Need / Cycle:</label><input type="range" id="consumptionRateSlider" min="0.05" max="1.0" step="0.05" value="0.25"><span id="consumptionRateLabel">0.25</span></div>
        <div class="control-group"><label for="speedSlider">Simulation Speed:</label><input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1"><span id="speedLabel">1.0x</span></div>
        <div class="control-group"><label for="reproCostSlider">Worker/Explorer Cost:</label><input type="range" id="reproCostSlider" min="100" max="5000" step="100" value="1000"><span id="reproCostLabel">1000</span></div>
        <div class="control-group"><label for="fighterReproCostSlider">Fighter Cost:</label><input type="range" id="fighterReproCostSlider" min="500" max="10000" step="100" value="2000"><span id="fighterReproCostLabel">2000</span></div>
        <div class="control-group"><label for="maxCarrySlider">Max Food per Ant:</label><input type="range" id="maxCarrySlider" min="5" max="100" step="5" value="25"><span id="maxCarryLabel">25</span></div>
        <div class="control-group"><label for="obstacleSizeSlider">Max Obstacle Size:</label><input type="range" id="obstacleSizeSlider" min="5" max="50" step="1" value="20"><span id="obstacleSizeLabel">20</span></div>
        <div class="control-group"><label for="obstacleDensitySlider">Obstacle Density:</label><input type="range" id="obstacleDensitySlider" min="0" max="0.0005" step="0.00001" value="0.0001"><span id="obstacleDensityLabel">0.0001</span></div>
        <div class="control-group"><label for="seedInput">World Seed:</label><input type="text" id="seedInput" value="ant_wars_v6.1_forage"><button id="applySeedBtn">Apply Seed & Reset</button></div>
        <button id="pauseBtn">Pause</button><button id="resetBtn">Reset Simulation</button>
    </div>
    <button id="togglePanelBtn">Hide</button>

    <div id="tooltip"></div>
    <div id="debug">Initializing...</div>

    <script>
        window.onload = function() {
            // --- DOM Elements --- (Same as before)
            const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); const tooltip = document.getElementById('tooltip'); const debug = document.getElementById('debug'); const colonyDisplayContainer = document.getElementById('colonyDisplayContainer'); const controlsPanel = document.getElementById('controls'); const togglePanelBtn = document.getElementById('togglePanelBtn'); const foodRateSlider = document.getElementById('foodRateSlider'); const foodRateLabel = document.getElementById('foodRateLabel'); const consumptionRateSlider = document.getElementById('consumptionRateSlider'); const consumptionRateLabel = document.getElementById('consumptionRateLabel'); const speedSlider = document.getElementById('speedSlider'); const speedLabel = document.getElementById('speedLabel'); const reproCostSlider = document.getElementById('reproCostSlider'); const reproCostLabel = document.getElementById('reproCostLabel'); const fighterReproCostSlider = document.getElementById('fighterReproCostSlider'); const fighterReproCostLabel = document.getElementById('fighterReproCostLabel'); const maxCarrySlider = document.getElementById('maxCarrySlider'); const maxCarryLabel = document.getElementById('maxCarryLabel'); const obstacleSizeSlider = document.getElementById('obstacleSizeSlider'); const obstacleSizeLabel = document.getElementById('obstacleSizeLabel'); const obstacleDensitySlider = document.getElementById('obstacleDensitySlider'); const obstacleDensityLabel = document.getElementById('obstacleDensityLabel'); const seedInput = document.getElementById('seedInput'); const pauseBtn = document.getElementById('pauseBtn'); const resetBtn = document.getElementById('resetBtn'); const applySeedBtn = document.getElementById('applySeedBtn');

            // --- Simulation State --- (Same as before)
            let ants = []; let foodSources = []; let pheromoneTrails = []; let obstacles = []; let colonies = []; let visualEffects = [];
            let isPaused = false; let simulationSpeed = 1; let foodSpawnChance = 0.01; let antConsumptionRate = 0.25; let reproductionCost = 1000; let fighterReproductionCost = 2000; let maxFoodPerAnt = 25; let maxObstacleSize = 20; let obstacleDensity = 0.0001; let currentSeed = 'ant_wars_v6.1_forage'; let antIdCounter = 0; let trailIdCounter = 0; let globalUpdateCounter = 0; let effectIdCounter = 0; let isPanelVisible = true;

            // --- Constants & Pathfinding (Same as before) ---
            const GRID_CELL_SIZE = 15; let grid = []; let gridWidth = 0; let gridHeight = 0;
            const STARTING_COLONY_FOOD = 150; const ANT_ENERGY_START = 100; const ANT_REPRO_ENERGY_THRESHOLD = 70; const FOOD_UNITS = 1000; const ANT_SPEED = 1; const ANT_SIZE = 3; const COLONY_SIZE = 15; const FOOD_SIZE = 5; const EXPLORER_RATIO_THRESHOLD = 0.3; const OBSTACLE_COLONY_MIN_DIST = 75; const MIN_COLONY_SEPARATION = 300;
            const EXPLORER_BASE_WANDER_DIST_MIN = 30; const EXPLORER_BASE_WANDER_DIST_MAX = 90; const EXPLORER_FAR_WANDER_MULTIPLIER = 2.5; const EXPLORER_AWAY_BIAS_THRESHOLD_FACTOR = 4; const EXPLORER_AWAY_BIAS_STRENGTH = 0.6;
            const WORKER_HEALTH = 80; const EXPLORER_HEALTH = 100; const FIGHTER_HEALTH = 150; const FIGHTER_DAMAGE = 8; const FIGHTER_ATTACK_RANGE = 15; const FIGHTER_DETECTION_RANGE = 60; const SCOUT_DETECTION_RANGE = 150; const FIGHTER_ATTACK_COOLDOWN = 15; const FIGHTER_RETREAT_HEALTH_THRESHOLD = 0.25; const FIGHT_TO_DEATH_THRESHOLD = FIGHTER_DAMAGE * 1.5; const KILL_PATROL_RETURNS = 2; const KILL_PATROL_LINGER_TIME = 60; const IDLE_PATROL_CHANCE = 0.01; const SCOUT_DESIGNATION_INTERVAL = 300;
            const COMBAT_SPARK_DURATION = 10; const COMBAT_SPARK_COUNT = 3; const COMBAT_SPARK_SIZE = 1.5; const DEATH_EFFECT_DURATION = 45; const DEATH_EFFECT_SIZE = ANT_SIZE * 1.5;
            const colonyPalettes = [ { base: '#FFA500', trail: 'rgba(255, 255, 0, 0.1)', worker: '#DC143C', explorer: '#FFD700', fighter: '#FF0000', fighterRange: 'rgba(255, 0, 0, 0.08)' }, { base: '#87CEEB', trail: 'rgba(0, 255, 255, 0.1)', worker: '#4682B4', explorer: '#AFEEEE', fighter: '#32CD32', fighterRange: 'rgba(50, 205, 50, 0.08)' } ];

            // Seeded PRNG
            function mulberry32(a) { return function() { var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
            let seededRandom;

            // Helper Functions
            function distance(p1, p2) { if (!p1 || !p2) return Infinity; const dx = p1.x - p2.x; const dy = p1.y - p2.y; return Math.sqrt(dx * dx + dy * dy); }
            function updateDebug(message) { if (debug) { debug.textContent = message; } }
            function updateColonyStats() { colonyDisplayContainer.innerHTML = ''; if (!colonies || colonies.length === 0) return; colonies.forEach((col) => { if (!col || !col.palette) return; const colonyAnts = ants.filter(ant => ant.colonyId === col.id && !ant.isDead); const workerCount = colonyAnts.filter(a => a.role === 'worker').length; const explorerCount = colonyAnts.filter(a => a.role === 'explorer').length; const fighterCount = colonyAnts.filter(a => a.role === 'fighter').length; const totalAnts = workerCount + explorerCount + fighterCount; const statsDiv = document.createElement('div'); statsDiv.className = 'control-group colony-stats'; statsDiv.style.borderColor = col.palette.base; statsDiv.innerHTML = ` <span style="font-weight: bold; color: ${col.palette.base};">Colony ${col.id + 1} Stats</span> <span>Food: ${Math.floor(col.storedFood)}</span> <span>Ants: ${totalAnts} (W:${workerCount}, E:${explorerCount}, F:${fighterCount})</span> <span>Patrol: ${col.enemyColonyLocation ? 'Active' : 'Inactive'}</span>`; colonyDisplayContainer.appendChild(statsDiv); }); }

            // --- Pathfinding (A*) --- (Same as before)
            class PathNode { constructor(x, y, gCost = Infinity, hCost = 0, parent = null) { this.x = x; this.y = y; this.gCost = gCost; this.hCost = hCost; this.fCost = gCost + hCost; this.parent = parent; } } function heuristic(nodeA, nodeB) { return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y); } function worldToGrid(worldX, worldY) { return { x: Math.floor(worldX / GRID_CELL_SIZE), y: Math.floor(worldY / GRID_CELL_SIZE) }; } function gridToWorld(gridX, gridY) { return { x: gridX * GRID_CELL_SIZE + GRID_CELL_SIZE / 2, y: gridY * GRID_CELL_SIZE + GRID_CELL_SIZE / 2 }; } function isWalkable(gridX, gridY) { return gridHeight > 0 && gridWidth > 0 && gridY >= 0 && gridY < gridHeight && gridX >= 0 && gridX < gridWidth && grid[gridY] && grid[gridY][gridX] === 0; } function findPath(startX, startY, endX, endY) { const startGrid = worldToGrid(startX, startY); const endGrid = worldToGrid(endX, endY); if (!isWalkable(startGrid.x, startGrid.y) || !isWalkable(endGrid.x, endGrid.y)) return null; if (startGrid.x === endGrid.x && startGrid.y === endGrid.y) return [gridToWorld(endGrid.x, endGrid.y)]; const openList = []; const closedList = new Set(); const startNode = new PathNode(startGrid.x, startGrid.y, 0, heuristic(startGrid, endGrid)); openList.push(startNode); let iterations = 0; const maxIterations = gridWidth * gridHeight * 1.5; while (openList.length > 0 && iterations < maxIterations) { iterations++; openList.sort((a, b) => a.fCost - b.fCost); const currentNode = openList.shift(); if (currentNode.x === endGrid.x && currentNode.y === endGrid.y) { const path = []; let temp = currentNode; while (temp !== null) { path.push(gridToWorld(temp.x, temp.y)); temp = temp.parent; } return path.reverse(); } closedList.add(`${currentNode.x},${currentNode.y}`); const neighbors = [ { x: currentNode.x + 1, y: currentNode.y }, { x: currentNode.x - 1, y: currentNode.y }, { x: currentNode.x, y: currentNode.y + 1 }, { x: currentNode.x, y: currentNode.y - 1 }, ]; for (const neighborCoords of neighbors) { if (!isWalkable(neighborCoords.x, neighborCoords.y) || closedList.has(`${neighborCoords.x},${neighborCoords.y}`)) continue; const gCost = currentNode.gCost + 1; const hCost = heuristic(neighborCoords, endGrid); const fCost = gCost + hCost; let neighborNode = openList.find(node => node.x === neighborCoords.x && node.y === neighborCoords.y); if (neighborNode === undefined) { neighborNode = new PathNode(neighborCoords.x, neighborCoords.y, gCost, hCost, currentNode); openList.push(neighborNode); } else if (gCost < neighborNode.gCost) { neighborNode.gCost = gCost; neighborNode.fCost = fCost; neighborNode.parent = currentNode; } } } return null; }

            // --- Visual Effects Class & Functions --- (Same as before)
             class VisualEffect { constructor(x, y, type, duration, color = null, size = null) { this.id = effectIdCounter++; this.x = x; this.y = y; this.type = type; this.initialDuration = duration; this.currentDuration = duration; this.color = color; this.size = size; } update() { this.currentDuration--; return this.currentDuration > 0; } draw(ctx) { const alpha = Math.max(0, this.currentDuration / this.initialDuration); if (this.type === 'combat_spark') { ctx.fillStyle = this.color ? `${this.color.slice(0, -1)}, ${alpha * 0.8})` : `rgba(255, 255, 0, ${alpha * 0.8})`; ctx.beginPath(); ctx.arc(this.x + (seededRandom()-0.5)*3, this.y + (seededRandom()-0.5)*3, this.size * alpha, 0, Math.PI * 2); ctx.fill(); } else if (this.type === 'death_marker') { ctx.fillStyle = this.color ? `${this.color.slice(0,-1)}, ${alpha * 0.5})` : `rgba(85, 85, 85, ${alpha * 0.5})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2); ctx.fill(); } } }
             function addCombatSparks(x, y, attackerColor) { for(let i = 0; i < COMBAT_SPARK_COUNT; i++) { visualEffects.push(new VisualEffect(x, y, 'combat_spark', COMBAT_SPARK_DURATION, attackerColor, COMBAT_SPARK_SIZE)); } }
             function addDeathMarker(x, y) { visualEffects.push(new VisualEffect(x, y, 'death_marker', DEATH_EFFECT_DURATION, 'rgba(85, 85, 85, 1)', DEATH_EFFECT_SIZE)); }

            // --- Classes (Colony, Obstacle) --- (Same as before)
            class Colony { constructor(id, x, y, palette) { this.id = id; this.x = x; this.y = y; this.storedFood = STARTING_COLONY_FOOD; this.palette = palette; this.enemyColonyLocation = null; } draw() { ctx.fillStyle = this.palette.base; ctx.beginPath(); ctx.arc(this.x, this.y, COLONY_SIZE, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.stroke(); } canAfford(type) { const cost = type === 'fighter' ? fighterReproductionCost : reproductionCost; return this.storedFood >= cost; } reproduce() { const canAffordWorker = this.canAfford('worker'); const canAffordFighter = this.canAfford('fighter'); if (!canAffordWorker && !canAffordFighter) return false; const potentialParent = ants.find(ant => ant.colonyId === this.id && !ant.isDead && ant.energy > ANT_REPRO_ENERGY_THRESHOLD && (ant.state === 'idle' || ant.state === 'returning')); if (!potentialParent) return false; const colonyAnts = ants.filter(a => a.colonyId === this.id && !a.isDead); const explorerCount = colonyAnts.filter(a => a.role === 'explorer').length; const workerCount = colonyAnts.filter(a => a.role === 'worker').length; const fighterCount = colonyAnts.filter(a => a.role === 'fighter').length; const totalActiveAnts = explorerCount + workerCount + fighterCount; let roleToSpawn = null; let cost = 0; const highFoodThreshold = Math.max(reproductionCost, fighterReproductionCost) * 3; const fighterSpawnChance = (this.storedFood > highFoodThreshold || this.enemyColonyLocation) ? 0.2 : 0.05; if (canAffordFighter && seededRandom() < fighterSpawnChance) { roleToSpawn = 'fighter'; cost = fighterReproductionCost; } else if (canAffordWorker && (totalActiveAnts <= 2 || (explorerCount / Math.max(1, workerCount + explorerCount)) < EXPLORER_RATIO_THRESHOLD)) { roleToSpawn = 'explorer'; cost = reproductionCost; } else if (canAffordWorker) { roleToSpawn = 'worker'; cost = reproductionCost; } else if (canAffordFighter) { roleToSpawn = 'fighter'; cost = fighterReproductionCost; } if (roleToSpawn) { this.storedFood -= cost; const newAnt = new Ant(this.x, this.y, roleToSpawn, this.id); ants.push(newAnt); return true; } return false; } }
            class Obstacle { constructor(x, y, radius) { this.x = x; this.y = y; this.radius = radius; } draw() { ctx.fillStyle = '#8B4513'; ctx.strokeStyle = '#A0522D'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); } }

            // --- Ant Class ---
            class Ant {
                constructor(x, y, role, colonyId) { this.id = antIdCounter++; this.colonyId = colonyId; this.x = x; this.y = y; this.role = role; this.energy = ANT_ENERGY_START; this.state = 'idle'; this.foodCarried = 0; this.target = null; this.currentPath = null; this.currentPathIndex = 0; this.currentTrailId = null; this.explorationTarget = null; this.movementTarget = null; this.isDead = false; this.maxHealth = this.role === 'fighter' ? FIGHTER_HEALTH : (this.role === 'explorer' ? EXPLORER_HEALTH : WORKER_HEALTH); this.currentHealth = this.maxHealth; this.attackCooldownTimer = 0; this.combatTarget = null; this.isActivelyScouting = false; this.lastKillLocation = null; this.patrolReturnCount = 0; this.patrolLingerTimer = 0; }
                getHomeColony() { return colonies.find(c => c.id === this.colonyId); }

                 update() {
                     if (this.isDead) return;
                     this.energy -= antConsumptionRate;
                     if (this.energy <= 0) { if (this.role === 'fighter' && this.state !== 'retreating') { this.startRetreating('Low Energy'); } else if(this.role !== 'fighter') { this.takeDamage(0.5); } }
                     if (this.attackCooldownTimer > 0) this.attackCooldownTimer--;
                     if (this.role === 'fighter' && this.currentHealth < this.maxHealth * FIGHTER_RETREAT_HEALTH_THRESHOLD && this.state !== 'retreating' && this.state !== 'dead') { this.startRetreating('Low Health'); }
                     if (this.patrolLingerTimer > 0) { this.patrolLingerTimer--; const enemy = this.findClosestEnemy(FIGHTER_DETECTION_RANGE); if (enemy) { this.combatTarget = enemy; this.target = enemy; this.state = 'attacking'; this.patrolLingerTimer = 0; this.resetPatrolScoutState(); } else if (this.patrolLingerTimer <= 0) { this.state = 'returningToPatrolPoint'; this.target = this.getHomeColony(); this.currentPath = null; this.findAndSetPath(); } return; }
                     if (this.currentPath && this.currentPathIndex < this.currentPath.length) { if (this.role === 'fighter' && this.state !== 'attacking' && this.state !== 'retreating' && this.state !== 'lingering') { if (this.checkForNearbyEnemiesDuringMovement()) { return; } } this.movementTarget = this.currentPath[this.currentPathIndex]; this.moveTo(this.movementTarget); if (distance(this, this.movementTarget) < GRID_CELL_SIZE / 2) { this.currentPathIndex++; if (this.currentPathIndex >= this.currentPath.length) { this.handlePathEnd(); } } return; } else { this.movementTarget = null; this.currentPath = null; }
                     switch (this.state) { case 'idle': if (this.role === 'fighter') this.fighterIdleAction(); else if (this.role === 'explorer') this.state = 'exploring'; else if (this.role === 'worker') this.workerIdleAction(); break; case 'exploring': this.explore(); break; case 'returning': case 'returningFromScoutFailure': this.handleReturningMovement(); break; case 'collecting': this.collectFoodAction(); break; case 'pathfinding': case 'pathfindingToPatrolPoint': this.findAndSetPath(); break; case 'attacking': this.fighterAttackAction(); break; case 'retreating': this.handleRetreatingMovement(); break; case 'returningToPatrolPoint': this.handlePatrolReturnMovement(); break; case 'lingering': break; case 'dead': break; }
                 }

                 checkForNearbyEnemiesDuringMovement() { let enemyFound = null; let minDist = FIGHTER_ATTACK_RANGE; for (const otherAnt of ants) { if (!otherAnt.isDead && otherAnt.colonyId !== this.colonyId) { const dist = distance(this, otherAnt); if (dist <= minDist) { minDist = dist; enemyFound = otherAnt; } } } if (enemyFound) { this.currentPath = null; this.currentPathIndex = 0; this.target = enemyFound; this.combatTarget = enemyFound; this.state = 'attacking'; this.resetPatrolScoutState(); return true; } return false; }

                 // *** MODIFIED workerIdleAction ***
                 workerIdleAction() {
                     const homeColony = this.getHomeColony(); if(!homeColony) return;

                     // Find ALL valid trails for this colony
                     const availableTrails = pheromoneTrails.filter(trail =>
                         trail.colonyId === this.colonyId &&
                         trail.targetFoodSource && // Ensure food source reference exists
                         foodSources.includes(trail.targetFoodSource) && // Ensure food source is still on the map
                         !trail.targetFoodSource.depleted &&
                         trail.targetFoodSource.amount > 0
                     );

                     if (availableTrails.length === 0) {
                         return; // No valid food sources known, stay idle
                     }

                     let bestSource = null;
                     let bestScore = -Infinity;

                     // Evaluate each potential source
                     for (const trail of availableTrails) {
                         const foodSource = trail.targetFoodSource;
                         const dist = distance(this, foodSource);

                         // Count competitors (same colony targeting the same food source)
                         let competitors = 0;
                         for(const otherAnt of ants) {
                             if (otherAnt.id !== this.id && !otherAnt.isDead && otherAnt.colonyId === this.colonyId && otherAnt.target === foodSource) {
                                 // Consider ants pathfinding to or collecting from the source as competitors
                                 if(otherAnt.state === 'pathfinding' || otherAnt.state === 'collecting') {
                                     competitors++;
                                 }
                             }
                         }

                         // Simple scoring: More food is good, less distance is good, fewer competitors is good.
                         // Adjust weights here to prioritize different factors
                         const distanceFactor = 1 / (dist + 1); // Add 1 to prevent division by zero if dist is 0
                         const competitionFactor = 1 / (competitors + 1);
                         const amountFactor = foodSource.amount;

                         // Example Score Calculation (can be tuned)
                         const score = amountFactor * distanceFactor * 50 + competitionFactor * 200; // Weighted more towards low competition and distance

                         if (score > bestScore) {
                             bestScore = score;
                             bestSource = foodSource;
                             // We don't strictly need the trail object anymore if we pathfind
                         }
                     }

                     // Assign the best source found
                     if (bestSource) {
                         this.target = bestSource;
                         this.state = 'pathfinding'; // Pathfind to the chosen source
                     }
                     // else: No suitable source found based on scoring, remain idle
                 }
                 // *** END MODIFIED workerIdleAction ***

                 fighterIdleAction() { const homeColony = this.getHomeColony(); if (!homeColony) return; const enemyColony = colonies.find(c => c.id !== this.colonyId); const nearbyEnemy = this.findClosestEnemy(FIGHTER_DETECTION_RANGE); if (nearbyEnemy) { this.combatTarget = nearbyEnemy; this.target = nearbyEnemy; this.state = 'attacking'; this.resetPatrolScoutState(); return; } if (this.isActivelyScouting && enemyColony) { if(!homeColony.enemyColonyLocation) { if(this.state === 'idle') { this.target = enemyColony; this.state = 'pathfinding'; } const scoutEnemy = this.findClosestEnemy(SCOUT_DETECTION_RANGE); if(scoutEnemy) { homeColony.enemyColonyLocation = { x: enemyColony.x, y: enemyColony.y }; this.isActivelyScouting = false; this.combatTarget = scoutEnemy; this.target = scoutEnemy; this.state = 'attacking'; } } else { this.isActivelyScouting = false; } return; } if (homeColony.enemyColonyLocation) { if (distance(this, homeColony) < COLONY_SIZE * 2 && seededRandom() < IDLE_PATROL_CHANCE) { const patrolRadius = 75; const patrolTargetX = homeColony.enemyColonyLocation.x + (seededRandom() - 0.5) * patrolRadius * 2; const patrolTargetY = homeColony.enemyColonyLocation.y + (seededRandom() - 0.5) * patrolRadius * 2; const gridTarget = worldToGrid(patrolTargetX, patrolTargetY); if (isWalkable(gridTarget.x, gridTarget.y)) { this.target = { x: patrolTargetX, y: patrolTargetY }; this.state = 'pathfinding'; this.resetPatrolScoutState(); return; } } } if (this.state === 'idle') { if (!this.explorationTarget || distance(this, this.explorationTarget) < 10) { const angle = seededRandom() * Math.PI * 2; const dist = seededRandom() * 40 + 10; let targetX, targetY, attempts = 0; do { targetX = Math.max(ANT_SIZE, Math.min(canvas.width - ANT_SIZE, homeColony.x + Math.cos(angle) * dist)); targetY = Math.max(ANT_SIZE, Math.min(canvas.height - ANT_SIZE, homeColony.y + Math.sin(angle) * dist)); attempts++; } while (!isWalkable(worldToGrid(targetX, targetY).x, worldToGrid(targetX, targetY).y) && attempts < 5); if (attempts < 5) this.explorationTarget = { x: targetX, y: targetY }; else this.explorationTarget = homeColony; } if (this.explorationTarget) { this.target = this.explorationTarget; this.state = 'pathfinding'; } } }
                 fighterAttackAction() { if (!this.combatTarget || this.combatTarget.isDead || this.combatTarget.state === 'dead') { this.combatTarget = null; this.target = null; this.state = 'idle'; return; } const distToTarget = distance(this, this.combatTarget); if (distToTarget <= FIGHTER_ATTACK_RANGE) { this.currentPath = null; if (this.attackCooldownTimer <= 0) { this.attack(this.combatTarget); this.attackCooldownTimer = FIGHTER_ATTACK_COOLDOWN; } } else { if (!this.currentPath || this.target !== this.combatTarget) { this.target = this.combatTarget; this.state = 'pathfinding'; } } }
                 attack(targetAnt) { const homeColony = this.getHomeColony(); if (!targetAnt || targetAnt.isDead || !homeColony || !homeColony.palette) return; targetAnt.takeDamage(FIGHTER_DAMAGE, this); addCombatSparks(targetAnt.x, targetAnt.y, homeColony.palette.fighter); }
                 takeDamage(amount, attacker = null) { if (this.isDead) return; this.currentHealth -= amount; if (this.currentHealth <= 0) { this.currentHealth = 0; this.die(attacker); } }
                 registerKill(killX, killY) { if (this.role !== 'fighter' || this.isDead) return; this.resetPatrolScoutState(); this.lastKillLocation = { x: killX, y: killY }; this.patrolReturnCount = KILL_PATROL_RETURNS; this.target = this.getHomeColony(); this.state = 'returningToPatrolPoint'; this.currentPath = null; this.findAndSetPath(); }
                 resetPatrolScoutState() { this.lastKillLocation = null; this.patrolReturnCount = 0; this.isActivelyScouting = false; this.patrolLingerTimer = 0; }
                 startRetreating(reason) { if (reason === 'Low Health' && this.currentHealth <= FIGHT_TO_DEATH_THRESHOLD) { return; } this.state = 'retreating'; this.combatTarget = null; this.target = this.getHomeColony(); this.currentPath = null; this.resetPatrolScoutState(); this.findAndSetPath(); }
                 handleRetreatingMovement() { const homeColony = this.getHomeColony(); if (!homeColony) { this.state = 'idle'; return; } if (distance(this, homeColony) < COLONY_SIZE + ANT_SIZE) { this.handleColonyArrival(); this.state = 'idle'; } else if (!this.currentPath) { this.target = homeColony; this.findAndSetPath(); if (!this.currentPath) { this.state = 'idle'; } } }
                 handleReturningMovement() { const homeColony = this.getHomeColony(); if (!homeColony) { this.state = 'idle'; return; } if (distance(this, homeColony) < COLONY_SIZE + ANT_SIZE) { this.handleColonyArrival(); this.state = 'idle'; this.resetPatrolScoutState(); } else if (!this.currentPath) { this.target = homeColony; this.state = 'pathfinding'; } }
                 handlePatrolReturnMovement() { const homeColony = this.getHomeColony(); if (!homeColony || !this.lastKillLocation) { this.state = 'idle'; this.resetPatrolScoutState(); return; } if (distance(this, homeColony) < COLONY_SIZE + ANT_SIZE) { this.handleColonyArrival(); this.patrolReturnCount--; if (this.patrolReturnCount > 0) { this.target = this.lastKillLocation; this.state = 'pathfindingToPatrolPoint'; this.currentPath = null; this.findAndSetPath(); } else { this.state = 'idle'; this.resetPatrolScoutState(); } } else if (!this.currentPath) { this.target = homeColony; this.findAndSetPath(); if (!this.currentPath) { this.state = 'idle'; this.resetPatrolScoutState();} } }
                 findClosestEnemy(range) { let closestEnemy = null; let minDistance = range; for (const otherAnt of ants) { if (!otherAnt.isDead && otherAnt.colonyId !== this.colonyId) { const dist = distance(this, otherAnt); if (dist < minDistance) { minDistance = dist; closestEnemy = otherAnt; } } } return closestEnemy; }
                 collectFoodAction() { const homeColony = this.getHomeColony(); if (!homeColony || !this.target || !foodSources.includes(this.target) || this.target.depleted || this.target.amount <= 0) { this.target = homeColony; this.state = 'pathfinding'; return; } const amountToTake = Math.min(this.target.amount, maxFoodPerAnt - this.foodCarried); if (amountToTake > 0) { this.foodCarried += amountToTake; this.target.amount -= amountToTake; if (this.target.amount <= 0) { this.target.depleted = true; pheromoneTrails = pheromoneTrails.filter(trail => trail.targetFoodSource === this.target); } } this.target = homeColony; this.state = 'pathfinding'; }
                 handlePathEnd() { const prevState = this.state; this.currentPath = null; this.currentPathIndex = 0; this.movementTarget = null; const homeColony = this.getHomeColony(); if (this.target instanceof FoodSource) { if (foodSources.includes(this.target) && !this.target.depleted && this.target.amount > 0) { this.state = 'collecting'; } else { this.target = homeColony; this.state = 'pathfinding'; } } else if (this.target instanceof Ant && this.target.colonyId !== this.colonyId) { this.combatTarget = this.target; this.state = 'attacking'; } else if (this.target === homeColony) { if(prevState === 'returningFromScoutFailure') { this.isActivelyScouting = false; this.state = 'idle'; } else if (prevState !== 'returningToPatrolPoint') { this.handleColonyArrival(); this.state = 'idle'; } } else if (prevState === 'pathfindingToPatrolPoint' && this.target === this.lastKillLocation) { this.state = 'idle'; this.patrolLingerTimer = KILL_PATROL_LINGER_TIME; } else if (this.target === this.explorationTarget || prevState === 'pathfinding') { if(this.isActivelyScouting) { this.state = 'returningFromScoutFailure'; this.target = homeColony; this.findAndSetPath(); } else { this.explorationTarget = null; this.state = 'idle'; } } else { this.state = 'idle'; this.target = null; } }
                 findAndSetPath() { if (!this.target) { const homeColony = this.getHomeColony(); if((this.isActivelyScouting || this.lastKillLocation) && homeColony && this.state !== 'retreating' ) { this.target = homeColony; this.state = this.isActivelyScouting ? 'returningFromScoutFailure' : 'returningToPatrolPoint'; this.resetPatrolScoutState(); } else if(this.state !== 'idle'){ this.state = 'idle'; this.currentPath = null; this.resetPatrolScoutState(); } return; } const targetX = this.target.x; const targetY = this.target.y; const path = findPath(this.x, this.y, targetX, targetY); if (path && path.length > 0) { this.currentPath = path; this.currentPathIndex = 0; } else { this.currentPath = null; this.currentPathIndex = 0; const homeColony = this.getHomeColony(); if (this.target === homeColony && this.state !== 'idle') { this.state = 'idle'; this.target = null; this.resetPatrolScoutState(); } else if (homeColony && this.state !== 'retreating' && this.state !== 'idle') { this.target = homeColony; this.state = this.isActivelyScouting ? 'returningFromScoutFailure' : (this.lastKillLocation ? 'returningToPatrolPoint' : 'pathfinding'); this.resetPatrolScoutState(); this.findAndSetPath(); } else if (this.state !== 'idle') { this.state = 'idle'; this.target = null; this.resetPatrolScoutState(); } } }
                 handleColonyArrival() { const homeColony = this.getHomeColony(); if (!homeColony) return; if (this.foodCarried > 0) { homeColony.storedFood += this.foodCarried; this.foodCarried = 0; } if (this.energy < ANT_ENERGY_START * 0.8 && homeColony.storedFood > 0) { const energyNeeded = ANT_ENERGY_START - this.energy; const foodToEat = Math.min(homeColony.storedFood, energyNeeded / 4); if (foodToEat > 0) { this.energy += foodToEat * 4; homeColony.storedFood -= foodToEat; this.energy = Math.min(this.energy, ANT_ENERGY_START); } } this.target = null; this.currentPath = null; this.currentTrailId = null; this.explorationTarget = null; this.movementTarget = null; this.combatTarget = null; if (this.state !== 'returningToPatrolPoint') { this.resetPatrolScoutState(); } }
                 explore() { const homeColony = this.getHomeColony(); if (!homeColony) return; for (const food of foodSources) { if (!food.depleted && food.amount > 0 && distance(this, food) < 50) { const foodGrid = worldToGrid(food.x, food.y); const selfGrid = worldToGrid(this.x, this.y); if (isWalkable(foodGrid.x, foodGrid.y) && isWalkable(selfGrid.x, selfGrid.y)) { this.foundFoodSource(food); return; } } } if (!this.explorationTarget || (this.currentPath === null && this.state === 'exploring')) { const distToColony = distance(this, homeColony); let targetDist = seededRandom() * (EXPLORER_BASE_WANDER_DIST_MAX - EXPLORER_BASE_WANDER_DIST_MIN) + EXPLORER_BASE_WANDER_DIST_MIN; if (distToColony > EXPLORER_AWAY_BIAS_THRESHOLD_FACTOR * 5) { targetDist *= EXPLORER_FAR_WANDER_MULTIPLIER; } let targetAngle = seededRandom() * Math.PI * 2; const awayBiasThreshold = COLONY_SIZE * EXPLORER_AWAY_BIAS_THRESHOLD_FACTOR; if (distToColony < awayBiasThreshold) { const angleToColony = Math.atan2(homeColony.y - this.y, homeColony.x - this.x); const angleAway = angleToColony + Math.PI; let dx1 = Math.cos(targetAngle); let dy1 = Math.sin(targetAngle); let dx2 = Math.cos(angleAway); let dy2 = Math.sin(angleAway); let biasedDx = dx1 * (1 - EXPLORER_AWAY_BIAS_STRENGTH) + dx2 * EXPLORER_AWAY_BIAS_STRENGTH; let biasedDy = dy1 * (1 - EXPLORER_AWAY_BIAS_STRENGTH) + dy2 * EXPLORER_AWAY_BIAS_STRENGTH; targetAngle = Math.atan2(biasedDy, biasedDx); } let attempts = 0; let targetX, targetY; do { targetX = Math.max(ANT_SIZE, Math.min(canvas.width - ANT_SIZE, this.x + Math.cos(targetAngle) * targetDist)); targetY = Math.max(ANT_SIZE, Math.min(canvas.height - ANT_SIZE, this.y + Math.sin(targetAngle) * targetDist)); if (attempts > 0) targetAngle += (seededRandom() - 0.5) * 0.5; attempts++; } while (!isWalkable(worldToGrid(targetX, targetY).x, worldToGrid(targetX, targetY).y) && attempts < 10); if (attempts < 10) { this.explorationTarget = { x: targetX, y: targetY }; this.target = this.explorationTarget; this.state = 'pathfinding'; } else { this.state = 'exploring'; } } }
                 foundFoodSource(foodSource) { const homeColony = this.getHomeColony(); if(!homeColony) return; const existingTrail = pheromoneTrails.find(t => t.colonyId === this.colonyId && t.targetFoodSource === foodSource); if (!existingTrail) { const newTrail = new PheromoneTrail(foodSource, [{ x: foodSource.x, y: foodSource.y }, { x: homeColony.x, y: homeColony.y }], this.colonyId); pheromoneTrails.push(newTrail); } this.target = homeColony; this.state = 'pathfinding'; this.explorationTarget = null; }
                 moveTo(targetPoint) { if (!targetPoint) return; const dx = targetPoint.x - this.x; const dy = targetPoint.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < ANT_SPEED) { if (dist > 0.1) { this.x = targetPoint.x; this.y = targetPoint.y; } } else { this.x += (dx / dist) * ANT_SPEED; this.y += (dy / dist) * ANT_SPEED; } this.x = Math.max(ANT_SIZE, Math.min(canvas.width - ANT_SIZE, this.x)); this.y = Math.max(ANT_SIZE, Math.min(canvas.height - ANT_SIZE, this.y)); }
                 die(killer = null) { if (this.isDead) return; this.isDead = true; this.state = 'dead'; this.energy = 0; this.foodCarried = 0; this.currentPath = null; this.currentHealth = 0; addDeathMarker(this.x, this.y); this.resetPatrolScoutState(); if (killer && killer.role === 'fighter' && !killer.isDead) { killer.registerKill(this.x, this.y); } }
                 draw() { const homeColony = this.getHomeColony(); if (!homeColony || !homeColony.palette) return; const palette = homeColony.palette; if (this.isDead) { ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(this.x, this.y, ANT_SIZE * 0.8, 0, Math.PI * 2); ctx.fill(); } else { if (this.role === 'fighter' && this.state !== 'retreating') { ctx.fillStyle = palette.fighterRange; ctx.beginPath(); ctx.arc(this.x, this.y, FIGHTER_ATTACK_RANGE, 0, Math.PI * 2); ctx.fill(); } ctx.fillStyle = this.role === 'fighter' ? palette.fighter : (this.role === 'explorer' ? palette.explorer : palette.worker); ctx.strokeStyle = ctx.fillStyle; switch (this.state) { case 'collecting': ctx.strokeStyle = 'yellow'; break; case 'returning': case 'pathfinding': case 'returningToPatrolPoint': case 'pathfindingToPatrolPoint': case 'returningFromScoutFailure': ctx.strokeStyle = 'cyan'; break; case 'exploring': ctx.strokeStyle = 'lime'; break; case 'attacking': ctx.strokeStyle = 'orange'; break; case 'retreating': ctx.strokeStyle = 'white'; break; case 'lingering': ctx.strokeStyle = '#FF00FF'; break; } ctx.lineWidth = (this.state === 'attacking' || this.state === 'retreating' || this.state === 'pathfinding' || this.state.includes('Patrol') || this.state.includes('Scout') || this.state === 'lingering') ? 1.5 : 1; if (this.isActivelyScouting) ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(this.x, this.y, ANT_SIZE, 0, Math.PI * 2); ctx.fill(); if (this.state !== 'idle' || this.isActivelyScouting) ctx.stroke(); if (this.foodCarried > 0) { ctx.fillStyle = 'lime'; ctx.beginPath(); ctx.arc(this.x + ANT_SIZE / 2, this.y - ANT_SIZE / 2, ANT_SIZE / 2, 0, Math.PI * 2); ctx.fill(); } } }
                 getTooltipInfo() { if (this.isDead) { return `ID: ${this.id} (Col: ${this.colonyId+1})\nRole: ${this.role}\nState: Dead`; } const pathStatus = this.currentPath ? `Path Len: ${this.currentPath.length - this.currentPathIndex}` : "No path"; const combatStatus = this.combatTarget ? `Target: Ant ${this.combatTarget.id}` : ""; const scoutStatus = this.isActivelyScouting ? " (Scouting)" : ""; const patrolStatus = this.lastKillLocation ? `\nPatrolling (${this.patrolReturnCount} left)` : ""; const lingerStatus = this.patrolLingerTimer > 0 ? ` (Lingering ${Math.ceil(this.patrolLingerTimer/10)}s)`:""; return `ID: ${this.id} (Col: ${this.colonyId+1})\nRole: ${this.role}${scoutStatus}\nState: ${this.state}${lingerStatus}\nHealth: ${this.currentHealth.toFixed(0)}/${this.maxHealth}\nEnergy: ${this.energy.toFixed(1)}\nFood: ${this.foodCarried.toFixed(0)}\n${pathStatus}${patrolStatus}\n${combatStatus}`; }
             }
            // --- FoodSource, PheromoneTrail Classes (Same as before) ---
            class FoodSource { constructor(x, y) { this.id = Math.random().toString(16).substring(2, 8); this.x = x; this.y = y; this.amount = FOOD_UNITS; this.depleted = false; } draw() { if (this.depleted) return; const sizeFactor = Math.max(0.2, this.amount / FOOD_UNITS); ctx.fillStyle = '#90EE90'; ctx.beginPath(); ctx.arc(this.x, this.y, FOOD_SIZE * sizeFactor, 0, Math.PI * 2); ctx.fill(); } }
            class PheromoneTrail { constructor(foodSource, pathPoints, colonyId) { this.id = trailIdCounter++; this.colonyId = colonyId; this.targetFoodSource = foodSource; this.path = pathPoints; this.strength = 1.0; } draw() { if (!this.targetFoodSource || this.targetFoodSource.depleted) return; const colony = colonies.find(c => c.id === this.colonyId); if (!colony || !colony.palette) return; ctx.strokeStyle = colony.palette.trail; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.targetFoodSource.x, this.targetFoodSource.y); ctx.lineTo(colony.x, colony.y); ctx.stroke(); } }

            // --- Simulation Logic --- (Functions: generateObstacles, placeColonies, initSimulation, spawnFood, designateScoutIfNeeded, update, draw, gameLoop) --- (Same logic as previous version, includes Visual Effects update/draw)
             function generateObstacles() { obstacles = []; if (gridWidth <= 0 || gridHeight <= 0) return; for (let y = 0; y < gridHeight; y++) { if(grid[y]) grid[y].fill(0); else grid[y] = new Array(gridWidth).fill(0); } let seedVal = 0; for (let i = 0; i < currentSeed.length; i++) { seedVal = (seedVal << 5) - seedVal + currentSeed.charCodeAt(i); seedVal |= 0; } seededRandom = mulberry32(seedVal); const numObs = Math.floor(canvas.width * canvas.height * obstacleDensity); let placed = 0; let att = 0; const maxAtt = numObs * 5; while (placed < numObs && att < maxAtt) { att++; const r = seededRandom() * (maxObstacleSize - 5) + 5; const x = seededRandom() * (canvas.width - r * 2) + r; const y = seededRandom() * (canvas.height - r * 2) + r; let tooClose = false; if(colonies && colonies.length > 0) { for (const col of colonies) { if (distance({ x, y }, col) < OBSTACLE_COLONY_MIN_DIST + r) { tooClose = true; break; } } } if (tooClose) continue; const newObs = new Obstacle(x, y, r); obstacles.push(newObs); placed++; const gXMin = Math.max(0, Math.floor((x - r) / GRID_CELL_SIZE)); const gXMax = Math.min(gridWidth - 1, Math.floor((x + r) / GRID_CELL_SIZE)); const gYMin = Math.max(0, Math.floor((y - r) / GRID_CELL_SIZE)); const gYMax = Math.min(gridHeight - 1, Math.floor((y + r) / GRID_CELL_SIZE)); for (let gy = gYMin; gy <= gYMax; gy++) { if (gy < 0 || gy >= gridHeight || !grid[gy]) continue; for (let gx = gXMin; gx <= gXMax; gx++) { if (gx < 0 || gx >= gridWidth) continue; const cX = gx * GRID_CELL_SIZE + GRID_CELL_SIZE / 2; const cY = gy * GRID_CELL_SIZE + GRID_CELL_SIZE / 2; if (distance({ x: cX, y: cY }, newObs) < r) { grid[gy][gx] = 1; } } } } }
             function placeColonies() { colonies = []; const pad = COLONY_SIZE + 50; if (gridWidth <= 0 || gridHeight <= 0) return; let c1Pos, att1 = 0; do { c1Pos = { x: pad + seededRandom() * (canvas.width * 0.3), y: canvas.height / 2 + (seededRandom() - 0.5) * (canvas.height * 0.4) }; att1++; } while (!isWalkable(worldToGrid(c1Pos.x, c1Pos.y).x, worldToGrid(c1Pos.x, c1Pos.y).y) && att1 < 50); if(att1 >= 50) console.warn("C1 place issue"); colonies.push(new Colony(0, c1Pos.x, c1Pos.y, colonyPalettes[0])); let c2Pos, att2 = 0; do { att2++; c2Pos = { x: canvas.width - pad - seededRandom() * (canvas.width * 0.3), y: canvas.height / 2 + (seededRandom() - 0.5) * (canvas.height * 0.4) }; } while ((!isWalkable(worldToGrid(c2Pos.x, c2Pos.y).x, worldToGrid(c2Pos.x, c2Pos.y).y) || distance(c1Pos, c2Pos) < MIN_COLONY_SEPARATION) && att2 < 50); if (att2 >= 50) { console.warn("C2 place issue"); do { c2Pos = { x: seededRandom() * (canvas.width - pad*2) + pad, y: seededRandom() * (canvas.height - pad*2) + pad }; att2++;} while ((!isWalkable(worldToGrid(c2Pos.x, c2Pos.y).x, worldToGrid(c2Pos.x, c2Pos.y).y) || distance(c1Pos, c2Pos) < COLONY_SIZE * 4) && att2 < 100); } colonies.push(new Colony(1, c2Pos.x, c2Pos.y, colonyPalettes[1])); }
             function initSimulation(preserveSettings = false) { console.log("Initializing..."); let saved = {}; if (preserveSettings) { saved = { foodSpawnChance: parseFloat(foodRateSlider.value), antConsumptionRate: parseFloat(consumptionRateSlider.value), simulationSpeed: parseFloat(speedSlider.value), reproductionCost: parseInt(reproCostSlider.value), fighterReproductionCost: parseInt(fighterReproCostSlider.value), maxFoodPerAnt: parseInt(maxCarrySlider.value), maxObstacleSize: parseInt(obstacleSizeSlider.value), obstacleDensity: parseFloat(obstacleDensitySlider.value), currentSeed: seedInput.value }; } ants = []; foodSources = []; pheromoneTrails = []; obstacles = []; colonies = []; visualEffects = []; antIdCounter = 0; trailIdCounter = 0; effectIdCounter = 0; globalUpdateCounter = 0; canvas.width = window.innerWidth; canvas.height = window.innerHeight; currentSeed = preserveSettings ? saved.currentSeed : seedInput.value; let seedV = 0; for (let i = 0; i < currentSeed.length; i++) { seedV = (seedV << 5) - seedV + currentSeed.charCodeAt(i); seedV |= 0; } seededRandom = mulberry32(seedV); gridWidth = Math.ceil(canvas.width / GRID_CELL_SIZE); gridHeight = Math.ceil(canvas.height / GRID_CELL_SIZE); grid = []; if (gridHeight > 0 && gridWidth > 0) { for (let y = 0; y < gridHeight; y++) { grid[y] = new Array(gridWidth).fill(0); } } else { console.error("Grid init failed"); return; } placeColonies(); generateObstacles(); if(colonies && colonies.length > 0) { colonies.forEach(col => { for (let i = 0; i < 3; i++) ants.push(new Ant(col.x, col.y, 'worker', col.id)); for (let i = 0; i < 1; i++) ants.push(new Ant(col.x, col.y, 'explorer', col.id)); ants.push(new Ant(col.x, col.y, 'fighter', col.id)); }); designateScoutIfNeeded(); } else { console.error("No colonies."); } isPaused = false; pauseBtn.textContent = "Pause"; if (preserveSettings) { foodRateSlider.value = saved.foodSpawnChance; foodRateLabel.textContent = saved.foodSpawnChance.toFixed(3); consumptionRateSlider.value = saved.antConsumptionRate; consumptionRateLabel.textContent = saved.antConsumptionRate.toFixed(2); speedSlider.value = saved.simulationSpeed; speedLabel.textContent = `${saved.simulationSpeed.toFixed(1)}x`; reproCostSlider.value = saved.reproductionCost; reproCostLabel.textContent = saved.reproductionCost; fighterReproCostSlider.value = saved.fighterReproductionCost; fighterReproCostLabel.textContent = saved.fighterReproductionCost; maxCarrySlider.value = saved.maxFoodPerAnt; maxCarryLabel.textContent = saved.maxFoodPerAnt; obstacleSizeSlider.value = saved.maxObstacleSize; obstacleSizeLabel.textContent = saved.maxObstacleSize; obstacleDensitySlider.value = saved.obstacleDensity; obstacleDensityLabel.textContent = saved.obstacleDensity.toFixed(5); seedInput.value = saved.currentSeed; foodSpawnChance = saved.foodSpawnChance; antConsumptionRate = saved.antConsumptionRate; simulationSpeed = saved.simulationSpeed; reproductionCost = saved.reproductionCost; fighterReproductionCost = saved.fighterReproductionCost; maxFoodPerAnt = saved.maxFoodPerAnt; maxObstacleSize = saved.maxObstacleSize; obstacleDensity = saved.obstacleDensity; } else { foodSpawnChance = parseFloat(foodRateSlider.value); antConsumptionRate = parseFloat(consumptionRateSlider.value); simulationSpeed = parseFloat(speedSlider.value); reproductionCost = parseInt(reproCostSlider.value); fighterReproductionCost = parseInt(fighterReproCostSlider.value); maxFoodPerAnt = parseInt(maxCarrySlider.value); maxObstacleSize = parseInt(obstacleSizeSlider.value); obstacleDensity = parseFloat(obstacleDensitySlider.value); } updateColonyStats(); updateDebug("Sim Initialized"); console.log("Init ok."); }
             function spawnFood() { if (gridWidth <= 0 || gridHeight <= 0) return; const pad = 10; let att = 0; while (att < 10) { att++; const x = seededRandom() * (canvas.width - pad * 2) + pad; const y = seededRandom() * (canvas.height - pad * 2) + pad; let tooClose = false; if(colonies && colonies.length > 0) { for (const col of colonies) { if (distance({ x, y }, col) < COLONY_SIZE + FOOD_SIZE + 30) { tooClose = true; break; } } } if (tooClose) continue; let collides = false; for (const obs of obstacles) { if (distance({ x, y }, obs) < obs.radius + FOOD_SIZE + 2) { collides = true; break; } } if (collides) continue; const gridPos = worldToGrid(x,y); if (!isWalkable(gridPos.x, gridPos.y)) continue; foodSources.push(new FoodSource(x, y)); return; } }
             function designateScoutIfNeeded() { if (!colonies || colonies.length === 0) return; colonies.forEach(homeColony => { const enemyColony = colonies.find(c => c.id !== homeColony.id); if(enemyColony && !homeColony.enemyColonyLocation) { const isAnotherScouting = ants.some(a => a.colonyId === homeColony.id && a.role === 'fighter' && a.isActivelyScouting && !a.isDead); if (!isAnotherScouting) { const scoutCandidate = ants.filter(a => a.colonyId === homeColony.id && a.role === 'fighter' && a.state === 'idle' && !a.isDead) .sort((a, b) => b.currentHealth - a.currentHealth)[0]; if(scoutCandidate) { scoutCandidate.isActivelyScouting = true; scoutCandidate.target = enemyColony; scoutCandidate.state = 'pathfinding'; } } } }); }
             function update() { if (isPaused) return; globalUpdateCounter++; ants.forEach(ant => ant.update()); visualEffects = visualEffects.filter(effect => effect.update()); foodSources = foodSources.filter(food => !food.depleted); if (seededRandom() < foodSpawnChance) spawnFood(); if(colonies && colonies.length > 0) { colonies.forEach(col => { if (col.canAfford('worker') || col.canAfford('fighter')) { if (seededRandom() < 0.1) { col.reproduce(); } } }); } if (globalUpdateCounter % SCOUT_DESIGNATION_INTERVAL === 0) { designateScoutIfNeeded(); } if (globalUpdateCounter % 30 === 0) { updateColonyStats(); } }
             function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); obstacles.forEach(obs => obs.draw()); if(colonies && colonies.length > 0) colonies.forEach(col => col.draw()); pheromoneTrails.forEach(trail => trail.draw()); foodSources.forEach(food => food.draw()); ants.forEach(ant => ant.draw()); visualEffects.forEach(effect => effect.draw(ctx)); }
             function gameLoop() { const updatesPerFrame = Math.max(1, Math.floor(simulationSpeed)); for (let i = 0; i < updatesPerFrame; i++) { if (!isPaused) update(); } if (!isPaused && simulationSpeed % 1 !== 0 && seededRandom() < (simulationSpeed % 1)) update(); draw(); requestAnimationFrame(gameLoop); }

            // --- Event Listeners --- (Unchanged)
             pauseBtn.addEventListener('click', () => { isPaused = !isPaused; pauseBtn.textContent = isPaused ? "Resume" : "Pause"; updateDebug(isPaused ? "Simulation Paused" : "Simulation Resumed"); }); resetBtn.addEventListener('click', () => initSimulation(true)); applySeedBtn.addEventListener('click', () => { currentSeed = seedInput.value || "default" + Math.random(); seedInput.value = currentSeed; initSimulation(true); }); foodRateSlider.addEventListener('input', () => { foodSpawnChance = parseFloat(foodRateSlider.value); foodRateLabel.textContent = foodSpawnChance.toFixed(3); }); consumptionRateSlider.addEventListener('input', () => { antConsumptionRate = parseFloat(consumptionRateSlider.value); consumptionRateLabel.textContent = antConsumptionRate.toFixed(2); }); speedSlider.addEventListener('input', () => { simulationSpeed = parseFloat(speedSlider.value); speedLabel.textContent = `${simulationSpeed.toFixed(1)}x`; }); reproCostSlider.addEventListener('input', () => { reproductionCost = parseInt(reproCostSlider.value); reproCostLabel.textContent = reproductionCost; }); fighterReproCostSlider.addEventListener('input', () => { fighterReproductionCost = parseInt(fighterReproCostSlider.value); fighterReproCostLabel.textContent = fighterReproductionCost; }); maxCarrySlider.addEventListener('input', () => { maxFoodPerAnt = parseInt(maxCarrySlider.value); maxCarryLabel.textContent = maxFoodPerAnt; }); obstacleSizeSlider.addEventListener('input', () => { maxObstacleSize = parseInt(obstacleSizeSlider.value); obstacleSizeLabel.textContent = maxObstacleSize; updateDebug("Obstacle size changed. Reset to apply."); }); obstacleDensitySlider.addEventListener('input', () => { obstacleDensity = parseFloat(obstacleDensitySlider.value); obstacleDensityLabel.textContent = obstacleDensity.toFixed(5); updateDebug("Obstacle density changed. Reset to apply."); }); canvas.addEventListener('mousemove', (event) => { const rect = canvas.getBoundingClientRect(); const mouseX = event.clientX - rect.left; const mouseY = event.clientY - rect.top; let antFound = null; for (let i = ants.length - 1; i >= 0; i--) { const ant = ants[i]; if (!ant.isDead && distance({ x: mouseX, y: mouseY }, ant) < ANT_SIZE * 2.5) { antFound = ant; break; } } if (antFound) { tooltip.style.display = 'block'; tooltip.style.left = `${event.clientX + 10}px`; tooltip.style.top = `${event.clientY + 10}px`; tooltip.textContent = antFound.getTooltipInfo(); } else { tooltip.style.display = 'none'; } }); canvas.addEventListener('mouseout', () => { tooltip.style.display = 'none'; }); window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gridWidth = Math.ceil(canvas.width / GRID_CELL_SIZE); gridHeight = Math.ceil(canvas.height / GRID_CELL_SIZE); if (!isPanelVisible) { togglePanelBtn.style.right = '0px'; } else { setToggleButtonPosition(); } if(!isPaused) draw();});
            // --- Panel Toggle Logic (Unchanged) ---
            function setToggleButtonPosition() { if (!isPanelVisible) { togglePanelBtn.style.right = '0px'; } else { const panelWidth = controlsPanel.offsetWidth; const effectiveWidth = panelWidth > 0 ? panelWidth : 200; togglePanelBtn.style.right = `${effectiveWidth + 10}px`; } } togglePanelBtn.addEventListener('click', () => { isPanelVisible = !isPanelVisible; if (isPanelVisible) { controlsPanel.classList.remove('hidden'); togglePanelBtn.textContent = 'Hide'; } else { controlsPanel.classList.add('hidden'); togglePanelBtn.textContent = 'Show'; } setTimeout(setToggleButtonPosition, 50); }); setTimeout(setToggleButtonPosition, 100); // Initial set

            // --- Start Simulation ---
            try { initSimulation(false); requestAnimationFrame(gameLoop); }
            catch (error) { console.error("Init Error:", error); updateDebug(`Init Error: ${error.message}`); const errDiv = document.createElement('div'); errDiv.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);color:red;background:black;padding:20px;border:2px solid red;'; errDiv.textContent = `Fatal Error: ${error.message}. Console (F12).`; document.body.appendChild(errDiv); }
        };
    </script>
</body>
</html>